<!DOCTYPE html>
<html>
  <head>
    <link href="./output.css" rel="stylesheet">
    <meta charset="UTF-8" />
    <title>kolourmeans</title>
  </head>
  <body class="bg-slate-900">
<h1 class="text-center text-emerald-600 text-3xl mb-2 font-semibold font-mono">Heya! zoom into a point on the map and click to generate a colour palette based on the colours in your image.</h1>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<div id="map" style="height:400px;" class="border-4 border-emerald-600 m-4"></div>
<div class="flex flex-row">
<img id="map_image_elem" class="m-4 border-4 border-emerald-600">
<div id="c1" class="p-6 mt-4"></div>
<div id="c2" class="p-6 mt-4"></div>
<div id="c3" class="p-6 mt-4"></div>
<div id="c4" class="p-6 mt-4"></div>
<div id="c5" class="p-6 mt-4"></div>
</div>

<script>
const path = require('path') /*npm packages*/
const axios = require("axios");
const { nativeImage } = require('electron');
var map = L.map('map').setView([0,0], 3);
L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
  attribution: 'Google Satellite', maxZoom: 19
}).addTo(map);
map.on('click', async function(click) {
try {
var zoom = map.getZoom(); /*zoom,tileX,tileY converts from latitude/longitude to use when getting small image of place*/
var latLng = click.latlng; /* latlng (latitude/longitude) and point gets the place the user wants to turn into colour palette*/
var point = map.project(latLng, zoom); 
var tileX = Math.floor(point.x / 256);
var tileY = Math.floor(point.y / 256); 
let imageurl = `https://mt1.google.com/vt/lyrs=s&x=${tileX}&y=${tileY}&z=${zoom}`; /*showing the original img on the app*/
let image_elem = document.getElementById('map_image_elem')
image_elem.src = imageurl;
let img_array = await urltouint8array(`https://mt1.google.com/vt/lyrs=s&x=${tileX}&y=${tileY}&z=${zoom}`);
let imgBuffer = Buffer.from(img_array); /* Uint8Array into an Electron nativeImage */
let img_native = nativeImage.createFromBuffer(imgBuffer);
let bitmapBuffer = img_native.toBitmap(); /*turn to bitmap pixel data with the rgba values*/
let size = img_native.getSize(); 
let expectedLength = size.width * size.height * 4; // 4 bytes per pixel (bgra)
let colours = [];
for (let i = 0; i < bitmapBuffer.length; i += 4) { // stride of 4 to account for b,g,r,a if I is smaller than the bytes amount in bitmapbuffer then + 4 and run again
    const b = bitmapBuffer[i]; // i = multiple of 4 rounded down to the closest byte the loop is on.
    const g = bitmapBuffer[i + 1];
    const r = bitmapBuffer[i + 2];
    const a = bitmapBuffer[i + 3]; 
    colours.push([r, g, b]); // add to 'colours' array!
}
//fisher-yates shuffle algorithm
for (let current_index = colours.length -1; current_index > 0; current_index--) { //start from the last in array and go backwards
    let random_index = Math.floor(Math.random() * (current_index + 1));
    [colours[current_index], colours[random_index]] = [colours[random_index], colours[current_index]]; //swap place
}
let centroids = colours.slice(0,5); //pick 5 random colours as centroids
function euclidean_distance(rgb1,centroid) { // calculate distance between 1 colour and another 
    return Math.hypot(
    rgb1[0] - centroid[0],
    rgb1[1] - centroid[1],
    rgb1[2] - centroid[2]
  );
}
let centroidColours = [[], [], [], [], []];
function assign_cluster() {
  centroidColours = [[], [], [], [], []];
for (let current_index = colours.length -1; current_index >= 0; current_index--) {
  let rgb = colours[current_index];
  let distance1 = euclidean_distance(rgb,centroids[0]);
  let distance2 = euclidean_distance(rgb,centroids[1]);
  let distance3 = euclidean_distance(rgb,centroids[2]);
  let distance4 = euclidean_distance(rgb,centroids[3]);
  let distance5 = euclidean_distance(rgb,centroids[4]);
  let centroid_distances = [distance1, distance2, distance3, distance4, distance5]
  let minDistance = Math.min(...centroid_distances); //find the smallest number out of ^
  let minIndex = centroid_distances.indexOf(minDistance); //find what index of the array the smallest number is
  centroidColours[minIndex].push(rgb); // push the colour to the corresponding minindex array inside centroidcolors array 
}
console.log(centroidColours);
}
assign_cluster();
let newCentroid = [];
function new_centroid(cluster) {
let rSum = 0;
let gSum = 0;
let bSum = 0;
let count
for (let i = 0; i < centroidColours[cluster].length; i ++) {
  rSum += centroidColours[cluster][i][0];
  gSum += centroidColours[cluster][i][1]; 
  bSum += centroidColours[cluster][i][2]; 
}
count = centroidColours[cluster].length;
let centroidy = 
[Math.round(rSum / count),
Math.round(gSum / count),
Math.round(bSum / count)
]
newCentroid.push(centroidy);
}
function reassign_centroids() {
  newCentroid = [];
for (let i = 0; i < centroids.length; i ++) {
  new_centroid(i);
}
centroids = newCentroid;
}

console.log(newCentroid);
function labArrayToCss(lab) {
  return `lab(${lab[0]} ${lab[1]} ${lab[2]})`;
}
reassign_centroids();
for (let i = 0; i < 5; i ++) {
  assign_cluster();
  reassign_centroids();
}
let LABcentroids = []
function rgbToCielab(i) { // turn one colour to its cielab vers
  function gammaCorrect(c) {
  c = c / 255; // normalize from 0–255 to 0–1
  return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
}
  let l_r = gammaCorrect(centroids[i][0]); // rgb -> linear rgb
  let l_g = gammaCorrect(centroids[i][1]);
  let l_b = gammaCorrect(centroids[i][2]);
  let x = l_r * 0.4124 + l_g * 0.3576 + l_b * 0.1805; // D65 matrix to get xyz colour
  let y = l_r * 0.2126 + l_g * 0.7152 + l_b * 0.0722;
  let z = l_r * 0.0193 + l_g * 0.1192 + l_b * 0.9505;
  x *= 100;
  y *= 100;
  z *= 100;
  let scaledx = x / 95.047; // scale against white, D65
  let scaledy = y / 100;
  let scaledz = z / 108.883;
  let fX;
  let fY;
  let fZ;
  if (scaledx > 0.008856) {
     fX = Math.cbrt(scaledx);
  }
  else {
     fX = scaledx * 7.787 + 0.13793103448;
  }
  if (scaledy > 0.008856) {
     fY = Math.cbrt(scaledy);
  }
  else {
     fY = scaledy * 7.787 + 0.13793103448;
  }
  if (scaledz > 0.008856) {
     fZ = Math.cbrt(scaledz);
  }
  else {
     fZ = scaledz * 7.787 + 0.13793103448;
  }
  let L = fY * 116 - 16;
  let A = (fX - fY) * 500;
  let B = (fY - fZ) * 200;
  LABcentroids.push([L, A, B]);
}
for (let i = 0; i < centroids.length; i++) {
  rgbToCielab(i);
}
LABcentroids.sort((b, a) => a[0] - b[0]); //sort light -> dark
console.log(LABcentroids);

document.getElementById("c1").style.backgroundColor = labArrayToCss(LABcentroids[0]);
document.getElementById("c2").style.backgroundColor = labArrayToCss(LABcentroids[1]);
document.getElementById("c3").style.backgroundColor = labArrayToCss(LABcentroids[2]);
document.getElementById("c4").style.backgroundColor = labArrayToCss(LABcentroids[3]);
document.getElementById("c5").style.backgroundColor = labArrayToCss(LABcentroids[4]);
}

catch (err) {
   console.log(err);
}}
)
async function urltouint8array(url) { /*turn image url to int8 array*/
  const response = await axios.get(url, {
    responseType: 'arraybuffer'
  });
  return new Uint8Array(response.data);
} 

</script>
</body>
</html>