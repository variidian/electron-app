<!DOCTYPE html>
<html>
  <head>
    <link href="./output.css" rel="stylesheet">
    <meta charset="UTF-8" />
    <title>kolourmeans</title>
  </head>
  <body class="bg-slate-900">
<h1 class="text-center text-emerald-600 text-3xl mb-2 font-semibold font-mono">Heya! zoom into a point on the map and click to generate a colour palette based on the colours in your image.</h1>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<div id="map" style="height:400px;" class="border-4 border-emerald-600 m-4"></div>
<img id="map_image_elem" class="m-4 border-4 border-emerald-600">
<script>
const path = require('path') /*npm packages*/
const axios = require("axios");
const { nativeImage } = require('electron');
var map = L.map('map').setView([0,0], 3);
L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
  attribution: 'Google Satellite', maxZoom: 19
}).addTo(map);
map.on('click', async function(click) {
var zoom = map.getZoom(); /*zoom,tileX,tileY converts from latitude/longitude to use when getting small image of place*/
var latLng = click.latlng; /* latlng (latitude/longitude) and point gets the place the user wants to turn into colour palette*/
var point = map.project(latLng, zoom); 
var tileX = Math.floor(point.x / 256);
var tileY = Math.floor(point.y / 256); 
let imageurl = `https://mt1.google.com/vt/lyrs=s&x=${tileX}&y=${tileY}&z=${zoom}`; /*showing the original img on the app*/
let image_elem = document.getElementById('map_image_elem')
image_elem.src = imageurl;
let img_array = await urltouint8array(`https://mt1.google.com/vt/lyrs=s&x=${tileX}&y=${tileY}&z=${zoom}`);
let imgBuffer = Buffer.from(img_array); /* Uint8Array into an Electron nativeImage */
let img_native = nativeImage.createFromBuffer(imgBuffer);
let bitmapBuffer = img_native.toBitmap(); /*turn to bitmap pixel data with the rgba values*/
let size = img_native.getSize(); 
let expectedLength = size.width * size.height * 4; // 4 bytes per pixel (bgra)
let colours = [];
for (let i = 0; i < bitmapBuffer.length; i += 4) { // stride of 4 to account for b,g,r,a if I is smaller than the bytes amount in bitmapbuffer then + 4 and run again
    const b = bitmapBuffer[i]; // i = multiple of 4 rounded down to the closest byte the loop is on.
    const g = bitmapBuffer[i + 1];
    const r = bitmapBuffer[i + 2];
    const a = bitmapBuffer[i + 3]; 
    colours.push([r, g, b]); // add to 'colours' array!
}
//fisher-yates shuffle algorithm
for (let current_index = colours.length -1; current_index > 0; current_index--) { //start from the last in array and go backwards
    let random_index = Math.floor(Math.random() * (current_index + 1));
    [colours[current_index], colours[random_index]] = [colours[random_index], colours[current_index]]; //swap place
}
let centroids = colours.slice(0,5); //pick 5 random colours as centroids
function euclidean_distance(rgb1,centroid) { // calculate distance between 1 colour and another 
    return Math.hypot(
    rgb1[0] - centroid[0],
    rgb1[1] - centroid[1],
    rgb1[2] - centroid[2]
  );
}
let centroidColours = [[], [], [], [], []]; 
for (let current_index = colours.length -1; current_index > 0; current_index--) {
  let rgb = colours[current_index];
  let distance1 = euclidean_distance(rgb,centroids[0]);
  let distance2 = euclidean_distance(rgb,centroids[1]);
  let distance3 = euclidean_distance(rgb,centroids[2]);
  let distance4 = euclidean_distance(rgb,centroids[3]);
  let distance5 = euclidean_distance(rgb,centroids[4]);
  let centroid_distances = [distance1, distance2, distance3, distance4, distance5]
  let minDistance = Math.min(...centroid_distances); //find the smallest number out of ^
  let minIndex = centroid_distances.indexOf(minDistance); //find what index of the array the smallest number is
  centroidColours[minIndex].push(rgb); // push the colour to the corresponding minindex array inside centroidcolors array 
}
console.log(centroidColours);
let newCentroid = [];
centroids = newCentroid;
function new_centroid(cluster) {
let rSum = 0;
let gSum = 0;
let bSum = 0;
let count
for (let i = 0; i < centroidColours[cluster].length; i ++) {
  rSum += centroidColours[cluster][i][0];
  gSum += centroidColours[cluster][i][1]; 
  bSum += centroidColours[cluster][i][2]; 
}
count = centroidColours[cluster].length;
let centroidy = 
[Math.round(rSum / count),
Math.round(gSum / count),
Math.round(bSum / count)
]
newCentroid.push(centroidy);
}
new_centroid(0);
new_centroid(1);
new_centroid(2);
new_centroid(3);
new_centroid(4);
console.log(newCentroid);
}
)
async function urltouint8array(url) { /*turn image url to int8 array*/
  const response = await axios.get(url, {
    responseType: 'arraybuffer'
  });
  return new Uint8Array(response.data);
}
</script>
</body>
</html>